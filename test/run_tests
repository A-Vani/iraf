#!/bin/sh

# Doctest-alike IRAF test script. This will take text files with
# MarkDown syntax, extract all code lines (enclosed with ```), execute
# the lines that start with cl> or similar and compare the other lines
# with the output of the IRAF shells (cl, ecl, vocl).
#
# Copyright: 2017 Ole Streicher
# License: as IRAF
#

# IRAF shells to be tested
#IRAF_SHELLS="cl.e ecl.e vocl.e"
IRAF_SHELLS="ecl.e"

if [ -z "$iraf" ] ; then
    export iraf=$(cd $(dirname $0)/..; pwd)/
fi
if [ -z "$IRAFARCH" ] ; then
    export IRAFARCH=$(${iraf}unix/hlib/irafarch.sh)
fi

export arch=.${IRAFARCH}
export IRAFBIN=${iraf}bin${arch}/
export PATH=$HOME/.iraf/bin:${PATH}

# Test scripts
TEST_FILES=${iraf}/test/*.md

failure_file=$(mktemp -t iraftest.XXXXXXXXX)


# Run one test. If a failure happens, the full message will be appended to
# the $failure_file.
#
# Parameters:
#
#  - Executable of IRAF shell
#  - Commands to be executed
#  - Expected result string
#  - Test script reference (file name and line number)
#
run_test () {
    local CL="$1"
    local command="$2"
    local result="$3"
    local src="$4"
    local options="$5"
    local skip=$(echo "$options" | tr \  \\n | grep ^skip)
    local xfail=$(echo "$options" | tr \  \\n | grep ^xfail)
    local archs=$(echo "$options" | tr \  \\n | grep ^arch= | cut -d= -f2)
    local decimals=$(echo "$options" | tr \  \\n | grep ^decimals= | cut -d= -f2)
    if [ "$skip" ] ; then
	printf "s"
	return
    fi
    if [ "$archs" -a -z "$(echo $archs | tr , \\n | grep ^$IRAFARCH\$)" ] ; then
	printf "a"
	return
    fi
    local cmd_file=$(mktemp -t iraftest.XXXXXXXXX)
    printf "%b\nlogout\n" "$command" > "$cmd_file"
    res_file=$(mktemp -t iraftest.XXXXXXXXX)
    printf "%b\n" "$result" > "$res_file" 2>&1
    clres_file=$(mktemp -t iraftest.XXXXXXXXX)
    "${CL}" -f "$cmd_file" > "$clres_file" 2>&1
    diff_file=$(mktemp -t iraftest.XXXXXXXXX)
    diff_floatingpoint "$res_file" "$clres_file" "$decimals" > "$diff_file"
    if [ -s $diff_file ] ; then
	if [ "$xfail" ] ; then
	    printf "x"
	else
	    cat >> $failure_file <<EOF

=================== Failure in $src with $(basename $CL) ===================

Expected
========
$(cat $res_file)

Output
======
$(cat $clres_file)

Diff
====
$(cat $diff_file | tail -n +3)
EOF
	    printf "F"
	fi
    else
	printf "."
    fi
    rm -f $cmd_file $res_file $clres_file $diff_file
}

# Diff two files, with an optionally given floating point precision
# (in relevant decimals)
#
# Parameters:
#
#  - first file
#  - second file
#  - relevant decimals (optional)
#
diff_floatingpoint () {
    local file1="$1"
    local file2="$2"
    local decimals="$3"
    if [ -z "$decimals" ] ; then
	diff -uw "$file1" "$file2"
    else
	perl -pe 's/(-?\d+\.\d*)(E-?\d+)?/sprintf("%.'${decimals}'f%s", $1, $2)/ge' < "$file1" > "$file1".fp
	perl -pe 's/(-?\d+\.\d*)(E-?\d+)?/sprintf("%.'${decimals}'f%s", $1, $2)/ge' < "$file2" > "$file2".fp
	diff -uw "$file1".fp "$file2".fp
	rm -f "$file1".fp "$file2".fp
    fi
}

# Run all tests for a given IRAF shell and test script
#
# Parameters:
#
#  - Executable of IRAF shell
#  - File name for test script
#
run_tests () {
    local CL="$1"
    FILE="$2"
    in_code=0   # detect whether we are in a code section
    command=''  # collected commands
    result=''   # collected expected results
    filename='' # File name to read in
    options=''  # Test options
    lineno=0    # line counter
    cat "$FILE" | while read -r line ; do
	lineno=$(expr $lineno + 1)
	if [ "$in_code"  = 1 ] ; then
	    if echo "$line" | grep -q '^```$' ; then
		# we are at the end of a code section,
		# so let's execute the test if there was one
		if [ "$command" ] ; then
		    run_test "$CL" "$command" "$result" "$(basename ${FILE}):${l_start}" "$options"
		fi
		command=''
		result=''
		filename=''
		options=''
		in_code=0
	    elif [ "$filename" ] ; then
		# We are in a code line that is to be stored in a file
		printf "%s\n" "$line" >> "$filename"
	    elif echo "$line" | egrep -q '^[a-z>]+> ' ; then
		# We are in a code line that contains a command.
		# First add a command to print the full line so that
		# it appears in the output. Then add the command itself
		# And add the command to to the expected results.
		cmd=$(echo "$line" | sed 's/^[a-z>]*> //')
		if [ "$command" ] ; then
		    command="${command}\nprint '${line}'"
		    result="${result}\n${line}"
		else
		    command="print '${line}'"
		    result="${line}"
		fi
		command="${command}\n${cmd}"
	    else
		# We are in a code line that contains the response from IRAF.
		# Just add it to the expected results.
		result="${result}\n${line}"
	    fi
	elif echo "$line" | grep -q '^```$' ; then
	    # A new code section started. Store the next line number for
	    # reference
	    l_start=$(expr $lineno + 1)
	    in_code=1
	elif echo "$line" | egrep -q '^File: `.+`$' ; then
	    # There is some file content printed out in the next block.
	    # Just prepare to save it.
	    filename="$(echo $line | cut '-d`' -f2)"
	elif echo "$line" | egrep -q '^Test options: `.+`$' ; then
	    # Special test options
	    options="$(echo $line | cut '-d`' -f2)"
	else
	    filename=""
	    options=""
	fi
    done
    echo
}

for CL in $IRAF_SHELLS ; do
    if [ -x "${IRAFBIN}${CL}" ] ; then
	for t in $TEST_FILES ; do
	    tmp_dir=$(mktemp -d -t iraftest.XXXXXXXXX)
	    printf "%b" "$(basename ${t}) @ ${CL} "
	    cd "$tmp_dir" ; run_tests "${IRAFBIN}${CL}" "${t}"
	    rm -rf "${tmp_dir}"
	done
    else
	echo "IRAF shell $CL not found"
	stat "${IRAFBIN}${CL}" >> "$failure_file" 2>&1
    fi
done

if [ -s "$failure_file" ] ; then
    cat "$failure_file"
    rm -f "$failure_file"
    exit 1
fi

rm -f "$failure_file"
